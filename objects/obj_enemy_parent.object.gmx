<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_kinetic</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
image_speed = 0;
friction = 0.1;
level = 1;
str = 0;
stam = 0;
mana = 0;
luck = 0;
critRate = 0;
critDamage = 0;
expGain = level;
damage = 0;
totalDamage = 0;
totalFade = 0;
totalCrit = 1;
minSpotFov = 15;
minSpotRange = 96;
maxSpotFov = 45;
maxSpotRange = 196;
spotFov = minSpotFov;
spotRange = minSpotRange;
fire = 0;
equipWeapon = false;
weaponImage = spr_sword;
weaponAngle = 0;
weaponSide = 1;
alertTime = 0;
alertRate = 0.2;
alert = 0; //Alert level 0: Normal, 1: Alerted, 2: Spot
for(i = 0; i &lt; 10; i++){
    statusChange[i,0] = -1; //Effect type
    statusChange[i,1] = 0; //Effect time
    statusChange[i,2] = 0; //Effect strength
}
statusTimer = 0;
coordinates = ds_queue_create();
healthShow = 0;
wipeTime = 0;
hitInt = 0;
goX = 0;
goY = 0;
statusSystem = part_system_create();
statusType = part_type_create();
target = -1;
alarm[0] = 60;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>part_system_destroy(statusSystem);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>goX = irandom(room_width);
goY = irandom(room_height);
if(!place_free(goX,goY)){
    goX = irandom(room_width);
    goY = irandom(room_height);
}
if(ds_queue_size(coordinates) == 0) {ds_queue_enqueue(coordinates,goX,goY);}

if(canMove){
    if(ds_queue_size(coordinates) &gt; 0){
        goX = ds_queue_dequeue(coordinates);
        goY = ds_queue_dequeue(coordinates);
        if(irandom(10) &lt; 1){
            var newX, newY;
            newX = irandom(room_width);
            newY = irandom(room_height);
            if(!place_free(newX,newY)){
                newX = irandom(room_width);
                newY = irandom(room_height);
            }
            ds_queue_enqueue(coordinates,newX,newY);
        }
    }
}
alarm[0] = 300;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(healthShow == ceil((enemy_health/enemy_max_health)*100)){
    wipeTime = 30;
}
else{
    if(wipeTime &gt; 0){
        wipeTime --;
    }
    else{
        healthShow = var_wipe(healthShow,enemy_health,enemy_max_health,0,2);
    }
}
image_angle = direction;
if(canMove &amp;&amp; place_free(goX,goY)){
    if(point_distance(x,y,goX,goY) &gt; 10){
        direction = point_direction(x,y,goX,goY);
        speed = 1;
    }
    else{
        repeat(2) ds_queue_dequeue(coordinates);
    }
}
if (fire &lt; 1) {fire++;}
healthShow = clamp(healthShow,0,100);
if(enemy_health &lt;= 0){
    enemy_health = 0;
    global.xp += expGain;
    sendSystemMessage("+"+string(expGain)+" XP");
    /*with(instance_create(x,y-25,obj_dmg_inc)){
        damage = other.totalDamage;
        wait = -60;
        size = 1;
    }*/
    instance_destroy();
}
if(totalCrit &gt; 1) {totalCrit *= 0.9;} else {totalCrit = 1;}
if(totalFade &gt; 0) {totalFade -= 0.05;} else {totalDamage = 0;}
for(i = 0; i &lt; 10; i++){
    if(statusChange[i,1] &gt; 0){
        statusChange[i,1]--;
    }
    else{
        statusChange[i,1] = 0;
        //if(statusChange[i,0] == 1) {canMove = true;}
        for(j = i; j &lt; 9; j++){
            statusChange[j,0] = statusChange[j+1,0];
            statusChange[j,1] = statusChange[j+1,1];
            statusChange[j,2] = statusChange[j+1,2];
        }
    }
    if(statusChange[i,0] != -1){
        if(enemy_health &gt; 0){
            if(statusTimer mod 60 == 0) {
                switch(statusChange[i,0]){
                    //Fire
                    case 0: damage = statusChange[i,2]*60;
                            part_particles_create(statusSystem,x+irandom(4)*choose(-1,1),y+irandom(4)*choose(-1,1),statusType,1);
                            enemy_health -= damage;
                            totalDamage += damage;
                            totalFade = 5;
                            if(damage != 0) {
                                with(instance_create(x+irandom_range(-16,16),y-32+irandom(8),obj_dmg_inc)){
                                    damage = string(other.damage);
                                    color = orange;
                                    font = global.damage_font;
                                    size = 2;
                                }
                            }
                            break;
                    //Freezing
                    case 1: damage = statusChange[i,2];
                            enemy_health -= damage;
                            totalDamage += damage;
                            if(damage != 0) {
                                with(instance_create(x+irandom_range(-16,16),y-32+irandom(8),obj_dmg_inc)){
                                    damage = string(other.damage);
                                    color = aqua;
                                    font = global.damage_font;
                                    size = 2;
                                }
                            }
                            totalFade = 5;
                            break;
                }
            }
            if(statusChange[i,0]) {
                speed = 0;
                canMove = false;
            }
            part_particles_create(statusSystem,x+irandom(4)*choose(-1,1),y+irandom(4)*choose(-1,1),statusType,1);
            statusTimer++;
        }
    }
}
knockbackPerform();
if(instance_exists(obj_player)) {target = obj_player;}
if(equipWeapon) {
    if(fire &gt; 0) {
        if(distance_to_object(target) &lt; 32) {
            if(inViewRange(self,target,45)) {
                fire -= 20;
                weaponSide *= -1;
                knockback(target,self,1,2);
                enemyDealDamage(0);
            }
        }
}
}
if(canMove){
    if(inViewRange(self,target,spotFov)){
        if(point_distance(x,y,target.x,target.y) &lt; spotRange){
            alert = 2;
            alertTime = 300;
        }
    }
    else if(instance_exists(obj_force)) { 
        if(inViewRange(self,obj_force,spotFov)) {
            alert = 1;
            alertTime = 600;
        }
    }
}
if(alertTime &gt; 0){
    alertTime--;
}
else{
    alert = 0;
}
switch(alert){
    case 0: spotRange = var_wipe(spotRange,minSpotRange,100,0.05,0);
            spotFov = var_wipe(spotFov,minSpotFov,100,0.05,0);
            break;
    case 1: spotRange = var_wipe(spotRange,maxSpotRange,100,alertRate/2,0);
            spotFov = var_wipe(spotFov,minSpotFov*2,100,alertRate/2,0);
            if(alertTime &gt; 0){
                alertTime--;
            }
            else{
                alert = 0;
            }
            break;
    case 2: spotRange = var_wipe(spotRange,maxSpotRange,100,alertRate,0);
            spotFov = var_wipe(spotFov,maxSpotFov,100,alertRate,0);
            if(kbTime == 0){
                if(object_index != obj_enemy_wizard) {
                    direction = point_direction(x,y,target.x,target.y);
                    speed = 1;
                }
                else {
                    if(distance_to_object(target) &gt; 128) {
                        direction = point_direction(x,y,target.x,target.y);
                        speed = 1;
                    }
                    else {
                        if(fire &gt; 0) {
                            fire -= 20;
                            with(instance_create(x,y,obj_enemy_force)) {
                                direction = point_direction(x,y,other.target.x,other.target.y);
                                speed = 4;
                                dmg_type = 1;
                                critRate = other.critRate;
                                critDamage = other.critDamage;
                                damage = other.mana;
                                dmg_mod = 2;
                                isMagic = true;
                                visible = false;
                            }
                        }
                    }
                }
                alarm[0] = 60;
            }
            break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_wall">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>move_contact_solid(direction,speed+10);
speed = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_force">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(alert != 2) {
    direction = -other.direction;
    //Make stay in place
    goX = x;
    goY = y;
    ds_queue_clear(coordinates);
    alarm[0] = 60;
    alertTime = 600;
    alert = 1;
}
image_angle = other.direction;
ds_queue_clear(coordinates);
for(var i = 0; i &lt; 10; i++){
    ds_queue_enqueue(coordinates,x+lengthdir_x(i*10,point_direction(x,y,other.x,other.y)));
    ds_queue_enqueue(coordinates,y+lengthdir_y(i*10,point_direction(x,y,other.x,other.y)));
}
if(other.canDamage){
    if(other.allowPierce){ //peircing
        if(!inArray(other.pierce,id)){
            playerDealDamage(other.dmg_type,false);
            other.pierce[other.aIndex] = id;
            ++other.aIndex;
        }
    }
    else if(other.multiHit){ //multiple hit
        if(hitInt &lt; other.maxHitInt){ //Check interval
            hitInt++; // increment
        }
        else{
            hitInt = 0; //reset counter
            if(other.hit &lt; other.maxHit){//increment total allowed hit
                other.hit++;
            }
            else{
                with(other) {instance_destroy();}
            }
            playerDealDamage(other.dmg_type,false);
            // deal damage
        }
    }
    else{ //normal hit
        playerDealDamage(1,false);
        with(other){
            instance_destroy();
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_player">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>knockback(other,self,2,15);
enemyDealDamage(0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>move_wrap(true,true,0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_font(global.game_font);
draw_set_valign(fa_bottom);
draw_set_halign(fa_center);
var xx, yy, xv, yv;
xv = view_xview[0];
yv = view_yview[0];
xx = (x-xv)*windowXRatio;
yy = (y-yv)*windowYRatio;

/*var x1 = lengthdir_x(spotRange,image_angle-spotFov);
var y1 = lengthdir_y(spotRange,image_angle-spotFov);
var x2 = lengthdir_x(spotRange,image_angle+spotFov);
var y2 = lengthdir_y(spotRange,image_angle+spotFov);
draw_line(xx,yy,xx+x1,yy+y1);
draw_line(xx,yy,xx+x2,yy+y2);*/
/*
if(alert != 0) {
    draw_sprite(spr_alert,alert,xx,yy-40);
}
*/

draw_text_colour(xx,yy-26,"Lv."+string(level),white,white,white,white,1);
//draw_set_alpha(min((-point_distance(x,y,mouse_x,mouse_y)/(useSkill(52,1)+1))+1,1));
draw_rectangle_colour(xx-20,yy-16,xx+20,yy-26,0,0,0,0,false);
draw_rectangle_colour(xx-18,yy-18,xx-18+(healthShow/100)*36,yy-24,red,red,red,red,false);
draw_rectangle_colour(xx-18,yy-18,xx-18+((enemy_health/enemy_max_health)*36),yy-24,green,green,green,green,false);
draw_set_valign(fa_top);
draw_set_halign(fa_center);
//draw_set_alpha(1);
draw_set_font(global.damage_font);
//draw_text_transformed_colour(xx,yy-40,totalDamage,min(2,totalCrit),min(2,totalCrit),0,white,white,white,white,totalFade);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();
if(equipWeapon) {
    var weapon_x, weapon_y;
    weaponAngle = direction_wipe(weaponAngle,image_angle-(fire*weaponSide*20)-20,50);
    weapon_x = lengthdir_x(8,image_angle);
    weapon_y = lengthdir_y(8,image_angle);
    draw_sprite_ext(weaponImage,0,x+weapon_x,y+weapon_y,weaponSide,1,weaponAngle,white,1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
