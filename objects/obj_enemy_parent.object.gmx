<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_kinetic</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
canMove = true;
//shader = shader_get_uniform(shd_motionBlur,"pos");
image_speed = 0;
moveSpeed = 1;
level = 1;
str = 0;
stam = 0;
mana = 0;
luck = 0;
enemy_health = 0;
enemy_max_health = 1;
maxHealthBars = 0;
healthBars = 0;
critRate = 0;
critDamage = 0;
expGain = level;
goldDrop = 0;
damage = 0;
totalDamage = 0;
totalFade = 0;
totalCrit = 1;
minSpotFov = 15;
minSpotRange = 96;
maxSpotFov = 45;
maxSpotRange = 196;
spotFov = minSpotFov;
spotRange = minSpotRange;
fire = 0;
equipWeapon = false;
weaponImage = spr_sword;
weaponAngle = 0;
weaponSide = 1;
alertTime = 0;
alertRate = 0.2;
alert = 0; //Alert level 0: Normal, 1: Alerted, 2: Spot
for(i = 0; i &lt; 10; i++){
    statusChange[i,0] = -1; //Effect type
    statusChange[i,1] = 0; //Effect time
    statusChange[i,2] = 0; //Effect strength
}
statusTimer = 0;
coordinates = ds_queue_create();
healthShow = 0;
wipeTime = 0;
hitInt = 0;
goX = 0;
goY = 0;
prevX = x div global.gridSize;
prevY = y div global.gridSize;
toX = x div global.gridSize;
toY = y div global.gridSize;
path = path_add();
target = -1;
alarm[0] = 60;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_queue_destroy(coordinates);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (alert != 2) {
    goX = irandom(room_width);
    goY = irandom(room_height);
    if(!place_free(goX,goY)){
        goX = irandom(room_width);
        goY = irandom(room_height);
    }
    if(ds_queue_size(coordinates) == 0) {ds_queue_enqueue(coordinates,goX,goY);}
    
    if(canMove){
        if(ds_queue_size(coordinates) &gt; 0){
            goX = ds_queue_dequeue(coordinates);
            goY = ds_queue_dequeue(coordinates);
            if(irandom(10) &lt; 1){
                var newX, newY;
                newX = irandom(room_width);
                newY = irandom(room_height);
                if(!place_free(newX,newY)){
                    newX = irandom(room_width);
                    newY = irandom(room_height);
                }
                ds_queue_enqueue(coordinates,newX,newY);
            }
        }
    }
    alarm[0] = 300;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*if ((toX == x) &amp;&amp; (toY == y)) {
    if ((prevX != toX) || (prevY != toY)) {
        mp_grid_clear_cell(global.grid,prevX div global.gridSize, prevY div global.gridSize);
        prevX = x;
        prevY = y;
    }
    if (mp_grid_get_cell(global.grid,toX div global.gridSize, toY div global.gridSize) == -1) {
        toX = x;
        toY = y;
    }
    else {
        mp_grid_add_cell(global.grid, toX div global.gridSize, toY div global.gridSize);
    }
}
if (x &gt; toX) {
    x -= min(moveSpeed,x-toX);
}
if (x &lt; toX) {
    x += min(moveSpeed,toX-x);
}
if (y &gt; toY) {
    y -= min(moveSpeed,y-toY);
}
if (y &lt; toY) {
    y += min(moveSpeed,toY-y);
}*/
if(healthShow == ceil((enemy_health/enemy_max_health)*100)){
    wipeTime = 30;
}
else{
    if(wipeTime &gt; 0){
        wipeTime --;
    }
    else{
        if (healthShow &gt; enemy_health/enemy_max_health) {
            healthShow = var_wipe(healthShow,enemy_health,enemy_max_health,0,2);
        }
        else {
            healthShow = 100;
        }
    }
}
if (kbTime == 0) {
    image_angle = direction;
}
if (alert != 2) {
    if(canMove &amp;&amp; place_free(goX,goY)){
        if(point_distance(x,y,goX,goY) &gt; 10){
            /*mp_grid_clear_cell(global.grid, x div global.gridSize, y div global.gridSize);
            var pathFound = mp_grid_path(global.grid,path,x,y,goX,goY,true);
            var xx = path_get_point_x(path,1);
            var yy = path_get_point_y(path,1);*/
            direction = point_direction(x,y,goX,goY);
            speed = moveSpeed;
        }
        else {
            speed = 0;
            repeat(2) ds_queue_dequeue(coordinates);
        }        
    }
}
if (fire &lt; 1) {fire++;}
healthShow = clamp(healthShow,0,100);
/****************************** DIES ***********************************/
if (enemy_health &lt;= 0) {
    if (healthBars &gt; 0) {
        healthBars--;
        enemy_health += enemy_max_health;
    }
    else {
        enemy_health = 0;
        global.xp += expGain;
        if (maxHealthBars &gt; 0) {
            expGain *= maxHealthBars;
            goldDrop *= maxHealthBars;
        }
        sendSystemMessage("+"+string(expGain)+" XP");
        dropGold(goldDrop);
        var dropPotionChance = irandom(25);
        if(dropPotionChance &lt; 5) {
            if(dropPotionChance mod 2 == 1) { 
                with(instance_create(x,y,obj_drop_item)) {image_index = 3;}
            }
            else {
                with(instance_create(x,y,obj_drop_item)) {image_index = 4;}
            }
        }
        /*with(instance_create(x,y-25,obj_dmg_inc)){
            damage = other.totalDamage;
            wait = -60;
            size = 1;
        }*/
        instance_destroy();
    }
}
if(totalCrit &gt; 1) {totalCrit *= 0.9;} else {totalCrit = 1;}
if(totalFade &gt; 0) {totalFade -= 0.05;} else {totalDamage = 0;}
for(i = 0; i &lt; 10; i++){
    if(statusChange[i,1] &gt; 0){
        statusChange[i,1]--;
    }
    else{
        statusChange[i,1] = 0;
        //if(statusChange[i,0] == 1) {canMove = true;}
        for(j = i; j &lt; 9; j++){
            statusChange[j,0] = statusChange[j+1,0];
            statusChange[j,1] = statusChange[j+1,1];
            statusChange[j,2] = statusChange[j+1,2];
        }
    }
    if(statusChange[i,0] != -1){
        if(enemy_health &gt; 0){
            if(statusTimer mod 60 == 0) {
                switch(statusChange[i,0]){
                    //Fire
                    case 0: damage = statusChange[i,2];
                            enemy_health -= damage;
                            totalDamage += damage;
                            totalFade = 5;
                            if(damage != 0) {
                                with(instance_create(x+irandom_range(-16,16),y-32+irandom(8),obj_dmg_inc)){
                                    damage = string(other.damage);
                                    color = orange;
                                    font = global.damage_font;
                                    size = 2;
                                }
                            }
                            break;
                    //Freezing
                    case 1: damage = statusChange[i,2];
                            enemy_health -= damage;
                            totalDamage += damage;
                            if(damage != 0) {
                                with(instance_create(x+irandom_range(-16,16),y-32+irandom(8),obj_dmg_inc)){
                                    damage = string(other.damage);
                                    color = aqua;
                                    font = global.damage_font;
                                    size = 2;
                                }
                            }
                            totalFade = 5;
                            break;
                    //Posion
                    case 2: damage = statusChange[i,2]*2;
                            enemy_health -= damage;
                            totalDamage += damage;
                            if(damage != 0) {
                                with(instance_create(x+irandom_range(-16,16),y-32+irandom(8),obj_dmg_inc)){
                                    damage = string(other.damage);
                                    color = c_green;
                                    font = global.damage_font;
                                    size = 2;
                                }
                            }
                            totalFade = 5;
                            break;
                    //Bleed
                    case 3: damage = statusChange[i,2]*3;
                            enemy_health -= damage;
                            totalDamage += damage;
                            if(damage != 0) {
                                with(instance_create(x+irandom_range(-16,16),y-32+irandom(8),obj_dmg_inc)){
                                    damage = string(other.damage);
                                    color = red;
                                    font = global.damage_font;
                                    size = 2;
                                }
                            }
                            totalFade = 5;
                            break;
                }
            }
            if(statusChange[i,0]) {
                speed = 0;
                canMove = false;
            }
            switch(statusChange[i,0]) {
                case 0: 
                    part_particles_create(global.fireSystem,x+irandom(4)*choose(-1,1),y+irandom(4)*choose(-1,1),global.fireType,1);
                    break;
                case 1: 
                    part_particles_create(global.iceSystem,x+irandom(4)*choose(-1,1),y+irandom(4)*choose(-1,1),global.iceType,1);
                    break;
            }
            //part_particles_create(statusSystem,x+irandom(4)*choose(-1,1),y+irandom(4)*choose(-1,1),statusType,1);
            statusTimer++;
        }
    }
}
if(instance_exists(obj_player)) {target = obj_player;}
/***************** MELEE ATTACK ****************/
if(equipWeapon) {
    if(fire &gt; 0) {
        if(distance_to_object(target) &lt; 32) {
            if(inViewRange(self,target,45)) {
                fire -= 40;
                weaponSide *= -1;
                knockback(target,self,1,2);
                enemyDealDamage(0);
            }
        }
    }
}
if(canMove){
    if(inViewRange(self,target,spotFov)){
        if(point_distance(x,y,target.x,target.y) &lt;= spotRange){
            alert = 2;
            alertTime = 300;
        }
    }
    else if(instance_exists(obj_force)) { 
        if(inViewRange(self,obj_force,spotFov)) {
            if (point_distance(x,y,obj_force.x,obj_force.y) &lt;= spotRange) {
                alert = 1;
                alertTime = 600;
            }
        }
    }
    if(alertTime &gt; 0){
        alertTime--;
    }
    else{
        alert = 0;
    }
    switch(alert){
        case 0: spotRange = var_wipe(spotRange,minSpotRange,100,0.05,0);
                spotFov = var_wipe(spotFov,minSpotFov,100,0.05,0);
                break;
        case 1: spotRange = var_wipe(spotRange,maxSpotRange,100,alertRate/2,0);
                spotFov = var_wipe(spotFov,minSpotFov*2,100,alertRate/2,0);
                if(alertTime &gt; 0){
                    alertTime--;
                }
                else{
                    alert = 0;
                }
                break;
        case 2: spotRange = var_wipe(spotRange,maxSpotRange,100,alertRate,0);
                spotFov = var_wipe(spotFov,maxSpotFov,100,alertRate,0);
                if (instance_exists(obj_player)) { 
                    if(kbTime == 0) {
                        direction = point_direction(x,y,obj_player.x,obj_player.y);
                        if(object_index != obj_enemy_wizard) {
                            speed = moveSpeed;
                        }
                        else {
                            if(distance_to_object(target) &gt; 128) {
                                speed = moveSpeed/2;
                            }
                            else {
                                if(fire &gt; 0) {
                                    fire -= 40;
                                    with(instance_create(x,y,obj_enemy_force)) {
                                        direction = point_direction(x,y,other.target.x,other.target.y);
                                        speed = 4;
                                        dmg_type = 1;
                                        critRate = other.critRate;
                                        critDamage = other.critDamage;
                                        damage = other.mana;
                                        dmg_mod = 2;
                                        isMagic = true;
                                        visible = false;
                                    }
                                }
                            }
                        }
                        alarm[0] = 60;
                    }
                }
                else {
                    alert = 0;
                }
                break;
    }
}
knockbackPerform();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_wall">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>move_contact_solid(direction,speed+10);
speed = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_enemy_parent">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>move_contact_all(direction,12);
speed = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_force">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(alert != 2) {
    //Make stay in place
    ds_queue_clear(coordinates);
    for(var i = 0; i &lt; 10; i++){
        ds_queue_enqueue(coordinates,x+lengthdir_x(i*10,point_direction(x,y,other.x,other.y)));
        ds_queue_enqueue(coordinates,y+lengthdir_y(i*10,point_direction(x,y,other.x,other.y)));
    }
    alarm[0] = 1;
    alertTime = 120;
    alert = 2;
}
wipeTime = 30;
if(other.canDamage){
    if(other.allowPierce){ //piercing
        if(!inArray(other.pierce,id)){
            playerDealDamage(other.dmg_type,false);
            if (other.inflictBleed) {
                if (irandom(9) == 0) {
                    addStatus(3,120,global.str);
                }
            }
            other.pierce[other.aIndex] = id;
            ++other.aIndex;
        }
    }
    else if(other.multiHit){ //multiple hit
        if (other.hitInt == other.maxHitInt) {
            if(other.hit &lt; other.maxHit){//increment total allowed hit
                other.hit++;
            }
            else{
                with(other) {instance_destroy();}
            }
            playerDealDamage(other.dmg_type,false);
            if (other.inflictBleed) {
                if (irandom(9) == 0) {
                    addStatus(3,120,global.str);
                }
            }
            // deal damage
        }
    }
    else{ //normal hit
        playerDealDamage(other.dmg_type,false);
        if (other.inflictBleed) {
            if (irandom(9) == 0) {
                addStatus(3,120,global.str);
            }
        }
        with(other){
            instance_destroy();
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_player">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>knockback(other,self,2,15);
enemyDealDamage(0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>move_wrap(true,true,0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_font(global.game_font);
draw_set_valign(fa_bottom);
draw_set_halign(fa_center);
var xx, yy, xv, yv;
xv = view_xview[0];
yv = view_yview[0];
xx = (x-xv)*windowXRatio;
yy = (y-yv)*windowYRatio;

/*var x1 = lengthdir_x(spotRange,image_angle-spotFov);
var y1 = lengthdir_y(spotRange,image_angle-spotFov);
var x2 = lengthdir_x(spotRange,image_angle+spotFov);
var y2 = lengthdir_y(spotRange,image_angle+spotFov);
draw_line(xx,yy,xx+x1,yy+y1);
draw_line(xx,yy,xx+x2,yy+y2);*/
/*
if(alert != 0) {
    draw_sprite(spr_alert,alert,xx,yy-40);
}
*/
draw_set_valign(fa_bottom);
draw_set_halign(fa_center);
draw_text_colour(xx,yy-26,"Lv."+string(level),white,white,white,white,1);
draw_set_alpha(min((-point_distance(x,y,mouse_x,mouse_y)/64)+1,1));
if (healthBars &gt; 0) {
    draw_set_valign(fa_top);
    draw_set_halign(fa_right);
    draw_set_colour(white);
    draw_text(xx-6,yy-21,healthBars+1);
    draw_set_colour(white);
    draw_rectangle_colour(xx-12,yy-16,xx+20,yy-26,0,0,0,0,false);
    draw_rectangle_colour(xx-10,yy-18,xx-10+(healthShow/100)*28,yy-24,red,red,red,red,false);
    draw_rectangle_colour(xx-10,yy-18,xx-10+(max(0,enemy_health/enemy_max_health)*28),yy-24,green,green,green,green,false);
}
else {
    draw_rectangle_colour(xx-20,yy-16,xx+20,yy-26,0,0,0,0,false);
    draw_rectangle_colour(xx-18,yy-18,xx-18+(healthShow/100)*36,yy-24,red,red,red,red,false);
    draw_rectangle_colour(xx-18,yy-18,xx-18+(max(0,enemy_health/enemy_max_health)*36),yy-24,green,green,green,green,false);
}
draw_set_valign(fa_top);
draw_set_halign(fa_center);
draw_set_alpha(1);
draw_set_font(global.damage_font);
//draw_text_transformed_colour(xx,yy-40,totalDamage,min(2,totalCrit),min(2,totalCrit),0,white,white,white,white,totalFade);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//shader_set(shd_motionBlur);
//shader_set_uniform_f(shader,mouse_x/room_width,mouse_y/room_height);
draw_self();
//if (path_exists(path)) {draw_path(path,x,y,false);}
if(equipWeapon) {
    var weapon_x, weapon_y;
    weaponAngle = direction_wipe(weaponAngle,image_angle-(max(-20,fire)*weaponSide*20)-20,50);
    weapon_x = lengthdir_x(8,image_angle);
    weapon_y = lengthdir_y(8,image_angle);
    draw_sprite_ext(weaponImage,0,x+weapon_x,y+weapon_y,weaponSide,1,weaponAngle,white,1);
}
/*draw_line_width(x,y,x+lengthdir_x(spotRange,spotFov+image_angle),y+lengthdir_y(spotRange,spotFov+image_angle),2);
draw_line_width(x,y,x+lengthdir_x(spotRange,-spotFov+image_angle),y+lengthdir_y(spotRange,-spotFov+image_angle),2);
for (var i = -spotFov; i &lt;= spotFov; i++) {
    draw_line_width(x+lengthdir_x(spotRange,i+image_angle),y+lengthdir_y(spotRange,i+image_angle),x+lengthdir_x(spotRange,i+1+image_angle),y+lengthdir_y(spotRange,i+1+image_angle),2);
}
//shader_reset();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
